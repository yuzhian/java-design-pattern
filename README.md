## JAVA设计模式

```
├─src
│  ├─main
│  │  ├─java
│  │  │  ├─behavioral ----- 模式类型
│  │  │  │  ├─chain ------- 模式
│  │  │  │  │  ├─sample --- 图解设计模式中的样例
│  │  │  │  │  └─simple --- 直接使用角色名称的示例
```

[随书附件示例程序下载, 仅保留教程示例, 修正了语法问题, 移除类public修饰符等.](https://www.ituring.com.cn/book/1811)

## 适应设计模式

### Iterator 模式, 一个一个遍历

[Iterator 迭代器模式](src/behavioral/iterator/simple/IteratorDemo.java)

> 将循环抽象化, 通用化.

动机: 因为集合底层实现导致获取元素的方式不同, 因此遍历方式也不相同. 为了减少替换集合的具体实现的代价, 需要有一种统一的方式顺序访问一个聚合对象而无需关心它的内部构造.

原理: 分离遍历和实现, 解耦循环本身与集合的结构. 为集合接口定义通用的遍历接口, 对所有集合来说调用方最简单通用且必须的方法有两个: 为循环准备的判断条件和顺序获取元素.

角色: Iterator, ConcreteIterator, Aggregate, ConcreteAggregate.

- 抽象迭代器: 声明判断结束的方法和访问下一个元素的方法, 为不同数据结构提供统一的遍历机制;
- 具体迭代器: 针对具体聚合, 实现抽象迭代器;
- 抽象聚合类: 声明集合通用方法, 以及迭代器获取方法, 统一迭代器的获取方式;
- 具体聚合类: 根据自身结构实现抽象聚合, 管理维护聚合数据, 根据结构返回用于遍历本集合的迭代器供外部调用.

### Adapter 模式, 加个"适配器"以便于复用

- [Adapter 适配器模式(类适配器形式)](src/structural/adapter/simple_extends/SimpleExtendsDemo.java)
- [Adapter 适配器模式(对象适配器形式)](src/structural/adapter/simple_entrust/SimpleEntrustDemo.java)

> 填补 "现有的程序" 和 "所需的程序" 之间的差异.

动机: 已有的类能实现所需功能, 但需要稍作修改才能符合现有结构, 或者是第三方组件无法直接修改时, 需要将这个类的方法接口转换成客户希望的接口形式.

原理: 将适配器作为目标角色的子类或者实现类以使形式复合需求, 再通过继承或者委托来使用被适配角色中的方法, 然后在适配器中做修改以适应目标要求.

角色: Target, Client, Adaptee, Adapter

- 目标: 定义客户端所需方法的角色, 抽象类或接口;
- 请求者: 使用目标操作执行具体处理的对象;
- 被适配: 持有既定方法, 一般为实现了一个复杂的功能, 能满足需求的类, 但与目标方法或形式不一致的角色;
- 适配器: 关联目标和被适配角色, 通过继承来使用被适配角色的方法, 或通过委托来调用所持有的被适配对象的方法.

## 交给子类

### Template Method 模式, 将具体处理交给子类

[Template Method 模板方法模式](src/behavioral/template_method/simple/TemplateMethodDemo.java)

> 父类负责定义处理流程的框架, 子类负责实现具体处理.

动机: 一系列相似的程序存在相同的实现步骤, 在保持功能结构完整的情况下去除重复代码, 以及以后新增类似程序时只需新增并替换具体类.

原理: 通用化逻辑处理, 在父类中编写操作的流程框架, 而将某些步骤延迟到子类中.

角色: AbstractClass, ConcreteClass

- 抽象类: 将步骤拆解并声明为抽象方法提供给子类实现, 将抽象方法组合, 实现模板方法确定处理的流程;
- 具体类: 负责实现抽象方法, 这些抽象方法将在抽象类角色中的模板方法中被调用.

### Factory Method 模式, 将实例的生成交给子类

[Factory Method 工厂方法模式](src/creational/factory_method/simple/FactoryMethodDemo.java)

> 工厂方法模式是模板方法的"实例创建"版, 父类中定义生成实例的框架, 子类负责实现实例的具体加工.

动机: 存在一组产品创建过程复杂, 或者是需要同时做一些其他的复杂操作, 需简化创建过程, 且易于扩充.

原理: 通过引入工厂等级结构, 定义一个创建对象的接口, 让子类决定实例化哪个类.

角色: Product, Creator, ConcreteProduct, ConcreteCreator

- 抽象产品: 声明了产品实例所持有的接口;
- 抽象创建者: 声明了对一种产品实例化的工厂方法;
- 具体产品: 工厂模式的创建目标, 实现产品抽象方法;
- 具体创建者: 实现抽象工厂方法, 返回具体产品实例.

## 生成实例

### Singleton 模式, 只有一个实例

- [Singleton 单例模式(恶汉式, 懒汉式, 双重检查锁式, 静态内部类式, 枚举单例模式)](src/creational/singleton/simple/SingletonDemo.java)
- [Singleton 反射绕过单例模式以及防止被反射攻击](src/creational/singleton/simple/SingletonByReflectionDemo.java)

> 确保任何情况下在程序中只存在一个实例.

动机: 由于协调系统, 节约资源等原因, 程序中只需要一个实例存在, 应用于各种工厂, 管理器, 日志等

原理: 构造方法私有化, 阻止外部创建实例 -> 在本类中创建/获取实例 -> 提供一个全局的访问点供外部获取该实例.

角色: Singleton

- 单例角色: 无法被外部构造, 存在一个返回当前类的对象的方法, 这个方法总是返回同一个实例.

### Prototype 模式, 通过复制生成实例

[Prototype 原型模式以及深浅克隆](src/creational/prototype/simple/PrototypeDemo.java)

> 根据实例来生成新实例

动机: 复制现有的实例, 创建新的实例.

原理: 浅拷贝: 对栈内存(基本类型和引用地址(指针))的克隆, Object#clone()是浅克隆; 深拷贝: 对堆和栈内存的克隆; 如果使用默认克隆方法或者重写时使用super.clone(), 必须实现Cloneable接口,
仅重写clone(), 不必实现Cloneable接口

角色: Prototype, ConcretePrototype, Client

- 抽象原型: 声明克隆方法的接口或者抽象类;
- 具体原型: 克隆方法中返回自己的一个克隆对象;
- 使用者: 提出创建对象的请求, 并针对抽象原型类编程, 以提高扩展性.

### Builder 模式, 组装复杂的实例

[Builder 建造者模式](src/creational/builder/simple/BuilderDemo.java)

> 组装具有复杂结构的实例

动机: 一个复杂产品或功能存在多种组装方式.

原理: 将功能拆解, 由建造者实现每个细节的构建, 由指挥者完成构建的流程组合.

角色: Product, Builder, ConcreteBuilder, Director(GoF版) (Builder, ConcreteBuilder, Director, Client(图解版))

- 产品: 复杂的产品, 也可能是某个功能而不是具体的产品;
- 建造者: 规范产品对象的各个组成成分的建造以及获取产品的方法, 但不涉及具体的对象部件的创建;
- 具体建造者: 实现具体细节, 替换组装方式具体化复杂对象的各部分的创建, 在建造过程完成后, 提供产品的实例;
- 指挥者: 也叫导演, 监工, 指挥者按流程指挥建造者构建对象, 只保证顺序, 自身不应参与构建操作;
- 使用者: 使用建造者模式, 对外提供简化调用.

### Abstract Factory 模式, 将关联零件组装成产品

[Abstract Factory 抽象工厂模式](src/creational/abstract_factory/simple/AbstractFactoryDemo.java)

> 抽象工厂并不关心零件的具体实现, 它要做的是将"抽象零件"组装成"抽象产品", 将"单个抽象产品"组装成"产品族"

动机: 多个模块(抽象产品)构成一个产品族, 模块各自存在多个实现, 期望在不必为每个抽象产品指定实现的前提下, 创建出一族产品实例.

原理: 将具体产品根据产品抽象类型和产品族二维化, 抽象工厂负责声明一族抽象产品的创建方法, 具体工厂负责一族具体产品的创建.

- 产品族: 由同一个具体工厂生产, 从属不同抽象产品的一组具体产品.
- 产品等级结构: 产品等级结构即产品的继承结构, 一个产品等级结构由一个抽象产品和它的具体产品子类构成;

角色: AbstractProduct, ConcreteProduct, AbstractFactory, ConcreteFactory, Client(图解)

- 抽象产品: 声明一类产品共有的方法, 是一个产品等级结构中所有具体产品的抽象父类;
- 具体产品:
- 抽象工厂: 声明实例化一族产品的方法;
- 具体工厂:
- 委托者: 调用抽象工厂, 指定具体工厂, 获得一族产品.

## 分开考虑

### Bridge 模式, 将类的功能层次结构与实现层次结构分离

[Bridge 桥接模式](src/structural/bridge/simple/BridgeDemo.java)

> 将类的功能层次结构与实现层次结构分离

动机: 系统在存在多个维度且每个都存在实现变化的情况下, 用继承会造成类爆炸问题, 期望增加后的功能可以被"所有的实现"使用.

原理: 将功能区分为基本功能和扩展功能, 让它们单独变化, 独立实现基本功能的变化以及扩展功能的变化; 创建"桥"聚合基本功能; 扩展功能类继承"桥"来使用基本功能.

- 功能层次结构: 即父类负责基本功能, 子类负责扩充功能;
- 实现层次结构: 父类负责声明抽象方法, 子类负责实现.

角色: Abstraction, RefinedAbstraction, Implementor, ConcreteImplementor

- 抽象化: 定义基本功能并委托实现者完成;
- 扩充抽象化: 扩充新功能;
- 实现者: 实现了抽象化角色定义的基本功能;
- 具体实现者: 实现基本功能.

### Strategy 模式, 整体地替换算法

[Strategy 策略模式](src/behavioral/strategy/simple/StrategyDemo.java)

> 整体地替换解决问题的方案

动机: 一个解决问题的策略可以灵活指定, 用于在执行策略上存在扩展的场景, 计算方式, 执行方式, 处理方式等场景.

原理: 定义一系列算法, 把他们封装起来, 让策略算法独立于使用它的客户而变化, 使用委托这种弱关联关系可以很方便地整体替换策略(方案/方法/算法等).

角色: Strategy, ConcreteStrategy, Context

- 策略: 声明决定实现策略所必需的接口;
- 具体策略: 负责实现具体的策略;
- 上下文: 使用算法的角色, 持有一个策略实例的引用, 委托具体策略角色来实现需求.

## 一致性

### Composite 模式, 容器和内容的一致性

- [Composite 组合模式(透明组合模式)](src/structural/composite/simple_transparent/CompositeTransparentDemo.java)
- [Composite 组合模式(安全组合模式)](src/structural/composite/simple_safe/CompositeSafeDemo.java)

> 使容器和内容具有一致性, 创造出递归结构

动机: 树形递归结构中, 期望一致地方法处理终点对象和组合对象.

原理: 是用于把一组相似的对象当作一个单一的对象, 使终点对象和组对象具有一致性.

- 透明组合模式: 抽象构件声明所有构件中的方法, 如果某个构件不支持某个方法则抛出错误;
- 安全组合模式: 抽象构件声明构件中的公有方法, 各组件的扩展功能在各自组件内实现.

角色: Leaf, Composite, Component, Client

- 叶子构件: 内容对象, 叶子节点内不能放入其他对象;
- 容器构件: 容器节点对象, 它提供一个集合用于存储子节点;
- 抽象构件: 使叶子构件和容器构件具有一致性的角色, 为叶子构件和容器构件对象声明接口, 包含所有子类共有行为的声明和实现.

### Decorator 模式, 装饰边框与被装饰物的一致性

[Decorator 装饰模式](src/structural/decorator/simple/DecoratorDemo.java)

> 装饰模式又名包装(Wrapper)模式, 装饰者是被装饰者的子类, 因此构件被装饰后接口仍可使用.

动机: 在不改变构件方法的基础上动态地扩充功能.

原理: 以对客户端透明的方式扩展对象的功能, 是继承关系的一个替代方案.

角色: Component, ConcreteComponent, Decorator, ConcreteDecorator

- 抽象构件: 增加功能时的核心角色;
- 具体构件: 实现了抽象构件中的功能;
- 抽象装饰类: 是被装饰构件的子类, 负责给被装饰构件增加职责, 但是具体职责在其子类中实现. 它维护一个指向抽象构件对象的引用, 通过该引用可以调用装饰之前构件对象的方法, 并通过其子类扩展该方法, 以达到装饰的目的;
- 具体装饰类: 它是抽象装饰的子类, 负责向被装饰构件添加新的职责. 实现了被装饰构件的所有方法, 并在调用被装饰者前后扩充新的功能.

### Visitor 模式, 访问数据结构并处理数据

[Visitor 访问者模式](src/behavioral/visitor/simple/VisitorDemo.java)

> 分离数据结构和处理

动机: 在不改变数据结构的前提下, 增加作用于一组对象元素的新功能.

原理: 让元素将自身传给访问者处理, 访问者将自身传给元素供其使用(双重分发, 元素和访问者互相调用).

角色: Element, ConcreteElement, ObjectStructure, Visitor, ConcreteVisitor

- 抽象元素: 抽象元素, 一组复杂元素的共同父类, 增加一组方法设置访问者并调用访问者访问自身;
- 具体元素: 实现抽象元素, 调用访问者访问自身(将自己作为参数提供给访问者);
- 对象结构: 实现抽象元素的复合元素, 提供访问者访问它的子元素;
- 抽象访问者: 为抽象元素的每个实现都声明一个访问操作方法;
- 具体访问者: 对每个具体元素都做针对性访问操作.

### Chain of Responsibility 模式, 推卸责任

[Chain of Responsibility 责任链模式](src/behavioral/chain/simple/ChainDemo.java)

> 将多个对象组成一条责任链, 然后按照它们在责任链上的顺序一个一个地找出到底应该谁来负责处理.

动机: 一个请求有多种(或多道)处理处理程序时, 期望能随意更改调用的处理者以及顺序. 弱化请求与处理者之间的关系, 以及需要动态更改职责链顺序.

原理: 将处理者抽象, 每个处理程序作为单独的具体处理者; 将选择权交给具体处理者, 代替复杂的处理权判断; 处理者将责任推卸给下一个处理者, 由下一个处理者判断后执行.

角色: Handler, ConcreteHandler, Client

- 抽象处理者: 定义处理接口, 以方便统一调用; 定义指定处理者的方法并返回自身, 方便链式调用;
- 具体处理者: 进行判断后执行处理, 并返回处理结果;
- 请求者: 调用者.

## 简单化

### Facade 模式, 简单窗口

[Facade 外观模式](src/structural/facade/simple/FacadeDemo.java)

> 为互相关联在一起的错综复杂的类整理出高层接口

动机: 为了降低复杂性, 程序开发时常常划分为若干个子系统, 在调用时将需要了解各系统之间复杂的逻辑关系, 需减少外部与子系统内多个模块的交互.

原理: 提供一个高层接口, 封装内部复杂的交互, 对外提供一组简单API简化调用.

角色: SubSystem, Facade

- 子系统角色: 可以单独完成一个子系统功能的一个程序, 子系统可以被单独调用.
- 外观角色: 按指令调用多个子系统以完成一个复杂的功能.

### Mediator 模式, 只有一个仲裁者

[Mediator 中介者(仲裁者)模式](src/behavioral/mediator/simple/MediatorDemo.java)

> 组员向仲裁者报告, 仲裁者向组员下达指标.

动机: 一个程序中, 所有的对象互相关联, 互相制约, 降低程序内的通信复杂性.

原理: 禁止相关对象的互相调用, 所有调用请求交给仲裁者, 并提供被调用方法, 将控制逻辑交给仲裁者负责, 由仲裁者协调信息通信, 并支持松耦合, 使代码易于维护.

角色: Mediator, ConcreteMediator, Colleague, ConcreteMediator

- 中介者: 定义通信接口;
- 具体中介者: 维持对同事对象的引用和增删, 实现通信接口;
- 同事: 定义发送和接收方法, 维持抽象中介者引用;
- 具体同事: 与抽象同事类中定义的中介者通信.

## 管理状态

### Observer 模式, 发送状态变化通知

[Observer 观察者模式](src/behavioral/observer/simple/ObserverDemo.java)

> 对象状态发生变化时, 通知观察者

动机: 对象状态发生变化时, 需要进行相应处理.

原理: 定义对象之间的一种一对多依赖关系, 使得每当一个对象状态发生改变时, 其相关依赖对象皆得到通知并被自动更新.

角色: Subject, ConcreteSubject, Observer, ConcreteObserver

- 观察目标: 被观察的对象, 定义维护观察者方法和通知方法;
- 具体目标: 状态发生改变时, 观察者们发出通知;
- 观察者: 接收观察者发出的通知;
- 具体观察者: 接收到通知时去执行相应操作.

### Memento 模式, 保存对象状态

[Memento 备忘录模式](src/behavioral/memento/simple/MementoDemo.java)

> 在对象之外备份状态

动机: 在不破坏封装的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 必要时将对象恢复到原先保存的状态.

原理: 原发器增加备份和恢复的方法, 其余操作扔按之前进行, 由负责人选择时机备份快照.

角色: Originator, Memento, Caretaker

- 原发器: 负责本身的功能, 以及定义备份范围, 创建和恢复数据;
- 备忘录: 存储原发器要备份的数据, 仅供原发器和负责人使用;
- 负责人: 负责维护一个备忘录的列表, 并由负责人决定何时保留快照.

### State 模式, 用类表示状态

[State 状态模式](src/behavioral/state/simple/StateDemo.java)

> 用类表示状态, 通过切换类来更改对象的状态

动机: 一个程序的部分行为会根据状态发生改变.

原理: 将状态定义为类, 然后把行为放到状态中去.

角色: State, ConcreteState, Context

- 抽象状态: 定义一组依赖于状态的方法的集合, 即对象的在特定状态下所对应的行为;
- 具体状态: 实现具体状态下所进行的操作;
- 上下文: 对抽象状态编程, 使用状态类中的方法来完成自身的操作.

## 避免浪费

### Flyweight 模式, 共享对象, 避免浪费

[Flyweight 享元模式](src/structural/flyweight/simple/FlyweightDemo.java)

> 通过尽量共享实例来避免new出实例

动机: 一个类需要反复创建相同的实例, 并且频繁地创建销毁, 需要避免大量重复详细类的内存开销, 如各种连接池技术的场景.

原理: 通过细粒度对象复用, 减少连接创建/关闭来提升性能.

- 单纯享元模式: 将可以复用的对象共享, 避免频繁创建销毁, 但要求享元对象一经创建不可更改, 以确保可以复用.
- 复合享元模式: 将一些单纯享元对象使用组合模式加以组合, 复合享元对象本身不能共享, 但是它们可以分解成单纯享元对象, 而后者则可以共享|.

角色: Flyweight, ConcreteFlyweight, UnsharedConcreteFlyweight, FlyweightFactory(Flyweight, FlyweightFactory, client(图解版))

- 抽象享元: 定义提供内蕴状态的方法和设置外蕴状态的方法;
- 具体享元: 为内蕴状态提供存储空间, 内蕴状态: 不可修改, 不会随环境变化, 维护到享元工厂的享元池中.
- 非共享的具体享元: 储存外蕴状态, 外蕴状态: 并非所有享元数据都可以复用, 当存在会随环境变化的数据时, 可以在使用时将这些数据作为参数传入;
- 享元工厂: 创建并管理享元对象, 维护享元池;
- 客户端: 调用享元工厂获取享元类数据.

### Proxy 模式, 只在必要时生成实例

[Proxy 代理模式](src/structural/proxy/simple/ProxyDemo.java)

> 让代理人完成工作, 除非那些工作必须由本人来完成

动机: 为一个对象提供代理, 以在代理中控制对这个对象的访问, 并且不影响原有程序

原理: 代理人和主体拥有相同api, 代理人持有主体对象, 在必要时由主体对象完成核心操作.

角色: Subject, RealSubject, Proxy

- 抽象主体: 通过接口或抽象类声明真实角色实现的业务方法;
- 真实主体: 实现抽象主体, 定义真实角色所要实现的业务逻辑;
- 代理角色: 实现抽象主体, 是真实主体的代理, 持有一个真实主体, 通过委托主体对象完成核心方法, 并在前后附加自己的操作.

## 用类来表现

### Command 模式, 命令也是类

[Command 命令模式](src/behavioral/command/simple/CommandDemo.java)

> 对命令进行封装, 请求的一方发出请求, 要求执行一个操作; 接收的一方收到请求, 并执行操作.

动机: 调用者根据情况使用不同的接收者命令.

原理: 在调用者和接收者之间使用命令解耦, 将命令请求封装为一个对象, 使得可以用不同的请求来进行参数化.

角色:Command, ConcreteCommand, Invoker, Receive

- 抽象命令: 定义命令.
- 具体命令: 实现命令.
- 发动者: 调用命令执行相关方法.
- 接收者: 命令接收者, 命令执行时的对象.

### Interpreter 模式, 语法规则也是类

[Interpreter 解释器模式](src/behavioral/interpreter/simple/InterpreterDemo.java)

> 解释和执行自定义语法

动机: 使用mini语言提高代码的可复用性, 当需要修改时仅更改迷你语言, 如正则 cron等.

原理: 定义一个语言的文法, 并且建立一个解释器来解释该语言中的句子, 这里的"语言"是指使用规定格式和语法的代码.

角色: AbstractExpression, TerminalExpression, NonterminalExpression, Context

- 抽象表达式: 声明抽象的解释操作, 是终结符表达式和非终结符表达式的公共父类.
- 终结符表达式: 实现与文法中的终结符相关联的解释操作, 在句子中的每一个终结符都是该类的一个实例.
- 非终结符表达式: 实现文法中非终结符的解释操作, 非终结符一般是文法中的运算符, 用于连接表达式(包括终结符表达式和非终结符表达式), 因此其解释操作一般通过递归的方式来完成.
- 上下文: 又称为上下文类, 用于存储解释器之外的全局信息.

